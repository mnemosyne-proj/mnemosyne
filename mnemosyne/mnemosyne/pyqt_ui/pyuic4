#!/usr/bin/env python
#
# pyuic4 <Johannes.Baiter@gmail.com>
#

# This wraps PyQt5's uic to provide support for mnemosyne's own translation
# infrastructure.
# Most of the code is taken from a blogpost by mandel_macaque:
# http://www.themacaque.com/?p=816

import re
import sys
from io import BytesIO

from PyQt5 import QtCore


class CompileUi(object):

    def compile_ui(self, ui_file):
        # Import the uic compiler from pyqt and generate the .py files.
        # Something similar could be done with pyside but that is left as an
        # exercise for the reader.
        self._wrapuic()
        from PyQt5 import uic
        # We're using BytesIO instead of StringIO, as PyQt still uses
        # byte strings as of version 4.8.5
        output = BytesIO()
        uic.compileUi(ui_file, output)
        # Beyond PyQt 4.8.3, the 'retranslateUi' method is left empty
        # for some reason, here we fill it again.
        if hex(QtCore.PYQT_VERSION) > "0x40803":
            output.seek(0)
            output = self._fill_retranslate_method(output)
        output.seek(0)
        sys.stdout.write(output.read())

    def _fill_retranslate_method(self, source):

        """ Reads a python source file, scans for lines that contain
        strings marked to be translated with getext, and adds those lines
        to the "retranslateUi" method.
        We need this helper method because newer PyQt versions (everything
        after 4.8.3) just leave the 'retranslateUi' method empty.

        """

        i18n_rexp = re.compile(r"^.*_\(.*\).*$")
        output = BytesIO()
        i18n_elements = []
        for line in source:
            if not "def retranslateUi" in line:
                if i18n_rexp.match(line):
                    i18n_elements.append(line)
                output.write(line)
            else:
                if not i18n_elements and "def retranslateUi" not in line:
                    continue
                output.write(line)
                output.write("".join(i18n_elements))
        source.close()
        return output

    _wrappeduic = False
    @classmethod
    def _wrapuic(cls):

        """Wrap uic to use gettext's _() in place of tr()"""

        if cls._wrappeduic:
            return
        from PyQt5.uic.Compiler import compiler, qtproxies, indenter

        class _UICompiler(compiler.UICompiler):

            """Speciallized compiler for qt .ui files."""

            def createToplevelWidget(self, classname, widgetname):
                o = indenter.getIndenter()
                o.level = 0
                o.write('from mnemosyne.libmnemosyne.translator import _')
                return super(_UICompiler, self).createToplevelWidget(
                                   classname, widgetname)

        compiler.UICompiler = _UICompiler

        class _i18n_string(qtproxies.i18n_string):
            """Provide a translated text."""
            def __str__(self):
                return "_('%s')" % self.string.encode('string-escape')

        qtproxies.i18n_string = _i18n_string
        cls._wrappeduic = True


if __name__ == '__main__':
    compiler = CompileUi()
    compiler.compile_ui(sys.argv[1])
