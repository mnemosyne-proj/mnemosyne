<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How to write a new frontend &#8212; libmnemosyne 2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Criterion" href="criterion.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="how-to-write-a-new-frontend">
<h1>How to write a new frontend<a class="headerlink" href="#how-to-write-a-new-frontend" title="Permalink to this headline">Â¶</a></h1>
<p>libmnemosyne is designed in such a way that writing a new front is as painless as possible. All the code for running a GUI which is actually GUI toolkit independent is grouped in two controllers: the main ui controller and the review ui controller. In order to build a new frontend, you need to create a main widget which inherits from <code class="docutils literal"><span class="pre">MainWidget</span></code> and implements its interface, and similarly a review widget which inherits from <code class="docutils literal"><span class="pre">ReviewWidget</span></code>.</p>
<p>In order to get a feel for how this works, it&#8217;s best by starting to study the code for the ppygui_ui Windows Mobile client, which is the simplest possible frontend, as it only supports reviewing cards.</p>
<p>There are three files in that frontend:</p>
<ul class="simple">
<li>a startup script, which specifies which components your frontend wants to activate in libmnemosyne, whether you are running on a device which is resource limited, ... .</li>
<li>a main widget, which corresponds to the application level widget in the GUI toolkit, and is in charge of showing error dialogs, displaying menus.</li>
<li>the review widget, where you need to implement a.o. the code to display text in the question window, ... .</li>
</ul>
<p>To give a better feeling for how the division of labour between your own new GUI code and the GUI independent code in the controllers works, consider this example from the &#8216;add cards&#8217; functionality in the PyQt frontend.</p>
<p>When the user activates the menu option or icon to add cards, it will fire up a certain function, which in the PyQt frontend is called <code class="docutils literal"><span class="pre">add_cards()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QObject</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actionAddCards</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&quot;activated()&quot;</span><span class="p">),</span> <span class="n">MainWindow</span><span class="o">.</span><span class="n">add_cards</span><span class="p">)</span>
</pre></div>
</div>
<p>The implementation of this function is rather trivial, it just calls the controller:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_cards</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">controller</span><span class="p">()</span><span class="o">.</span><span class="n">show_add_cards_dialog</span><span class="p">()</span>
</pre></div>
</div>
<p>The code above is code you need to implement for your new frontend, but as you can see, it&#8217;s rather trivial.</p>
<p>The controller&#8217;s <code class="docutils literal"><span class="pre">show_add_cards_dialog</span></code> function looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">show_add_cards_dialog</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stopwatch</span><span class="p">()</span><span class="o">.</span><span class="n">pause</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">component_manager</span><span class="o">.</span><span class="n">get_current</span><span class="p">(</span><span class="s2">&quot;add_cards_dialog&quot;</span><span class="p">)</span>\
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component_manager</span><span class="p">)</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>
    <span class="n">review_controller</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">review_controller</span><span class="p">()</span>
    <span class="n">review_controller</span><span class="o">.</span><span class="n">reload_counters</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">review_controller</span><span class="o">.</span><span class="n">card</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">review_controller</span><span class="o">.</span><span class="n">new_question</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">review_controller</span><span class="o">.</span><span class="n">update_status_bar</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stopwatch</span><span class="p">()</span><span class="o">.</span><span class="n">unpause</span><span class="p">()</span>
</pre></div>
</div>
<p>This is where the heavy lifting is done, but it&#8217;s completely UI independent, and there should be no need for you to modify that code.</p>
<p>In order for the controller to know where it can find the actual add cards dialog, which for PyQt is called <code class="docutils literal"><span class="pre">AddCardsDlg</span></code> , you need to have that dialog derive from the abstract <code class="docutils literal"><span class="pre">libmnemosyne.ui_components.dialogs.AddCardsDialog</span></code>, and provide an activate function, which for the PyQt toolkit is simply:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally, you need to register the <code class="docutils literal"><span class="pre">AddCardsDlg</span></code> component. That is what the following line does inside the main startup script (which for PyQt is simply called <code class="docutils literal"><span class="pre">mnemosyne</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mnemosyne</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;mnemosyne.pyqt_ui.add_cards_dlg&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;AddCardsDlg&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Inside the <code class="docutils literal"><span class="pre">AddCardsDlg</span></code>, there is of course lots of UI specific code, but once the dialog has enough data to create the cards, it simply calls:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">controller</span><span class="p">()</span><span class="o">.</span><span class="n">create_new_cards</span><span class="p">(</span><span class="n">fact_data</span><span class="p">,</span> <span class="n">card_type</span><span class="p">,</span> <span class="n">grade</span><span class="p">,</span> <span class="n">tag_names</span><span class="p">)</span>
</pre></div>
</div>
<p>So, the <code class="docutils literal"><span class="pre">AddCardsDlg</span></code> should almost entirely consist of GUI dependent code. All the GUI indepedent code to actually create the cards is contained within the controller&#8217;s <code class="docutils literal"><span class="pre">create_new_cards()</span></code> method.</p>
<p>If you feel like you need to override the review or the main controller provided by libmnemosyne, please let the developpers know. Either its design is not general enough, or you are trying to work against libmnemosyne rather than with it.</p>
<p>Tips for creating a responsive client:</p>
<ul>
<li><p class="first">When instantiating a <code class="docutils literal"><span class="pre">libmnemosyne.Mnemosyne</span></code> object, there are two parameters you need to provide: <code class="docutils literal"><span class="pre">upload_science_logs</span></code> and <code class="docutils literal"><span class="pre">interested_in_old_reps</span></code>. If you are writing a mobile client which syncs to a desktop version of mnemosyne, it is recommended that you don&#8217;t deal with uploading the science logs yourself, but let the desktop client deal with that. As for <code class="docutils literal"><span class="pre">interested_in_old_reps</span></code>, if your mobile client does not include graphical statistics using the revision history, it does not make sense to store this history on your device.</p>
</li>
<li><p class="first">The standard instantiation of a <code class="docutils literal"><span class="pre">libmnemosyne.Mnemosyne</span></code> object includes all components in libmnemosyne. If you are writing a mobile client with e.g. only review capabilities, it does not make sense to include all these components. See the example of the Windows Mobile ppygui_ui frontend for a client which only uses the bare minimum of components to improve startup time.</p>
</li>
<li><p class="first">If your mobile client does not include a card browser, you can save some disk space by not storing pregenerated questions or answers. To achieve this, make sure you do not include the regular <code class="docutils literal"><span class="pre">SQLite</span></code> component, but this one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s2">&quot;mnemosyne.libmnemosyne.databases.SQLite_no_pregenerated_data&quot;</span><span class="p">,</span>
 <span class="s2">&quot;SQLite_NoPregeneratedData&quot;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">libmnemosyne does some optimisation by trying to show the next question before the grading of the previous question is completed. This improves the perceived responsiveness of the client. However, some GUI toolkits (e.g. Qt) queue widget updates and only excecute them when there is no more processing going on, thereby defeating libmnemosyne&#8217;s optimisation. For that reason, there is a function <code class="docutils literal"><span class="pre">review_widget().redraw_now</span></code> which is used to tell the GUI toolkit to do the repaint now. If your toolkit also has similar behaviour, implementing this function can really help to mask slow database access.</p>
</li>
<li><p class="first">If save operations are slow on your mobile device, you might want to consider setting a larger default value instead of <code class="docutils literal"><span class="pre">save_after_n_reps</span> <span class="pre">=</span> <span class="pre">1</span></code> in <code class="docutils literal"><span class="pre">config.py</span></code>.</p>
</li>
<li><p class="first">If media files will never be edited outside of Mnemosyne on your mobile device, you can save time during sync by setting <code class="docutils literal"><span class="pre">check_for_updated_media_files</span> <span class="pre">=</span> <span class="pre">False</span></code> in <code class="docutils literal"><span class="pre">config.py</span></code>.</p>
</li>
<li><p class="first">If you are really adventurous, you can set <code class="docutils literal"><span class="pre">backup_before_sync</span> <span class="pre">=</span> <span class="pre">True</span></code> in <code class="docutils literal"><span class="pre">config.py</span></code>.</p>
</li>
</ul>
<p>Notes:</p>
<ul class="simple">
<li>If you need access to the main widget when you are constructing the review widget, e.g. to specify it&#8217;s parent, you can access it using <cite>self.main_widget()`</cite></li>
<li>If you need access to some components of libmnemosyne to construct your widget (e.g. the configuration), these might not yet be available inside your <code class="docutils literal"><span class="pre">__init__()</span></code> method. In this case, you need to move that code to your widget&#8217;s <code class="docutils literal"><span class="pre">activate()</span></code> method, at which time all the other compoments will already be active.</li>
<li>Everything described here applies not only for Python frontends, but also for frontends not written in Python, which access libmnemosyne through an UDP socket or through the Python-embedded-in-C bridge.</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="criterion.html" title="previous chapter"><code class="docutils literal"><span class="pre">Criterion</span></code></a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/modules/how_to_write_a_new_frontend.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2008, Peter Bienstman.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="../_sources/modules/how_to_write_a_new_frontend.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>